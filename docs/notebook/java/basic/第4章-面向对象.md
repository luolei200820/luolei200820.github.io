# 第4章 面向对象

## 4.6 对象构造

### 4.6.1 重载

类可以有多个构造器，根据参数不同做区分，这种功能叫做**重载**

编译器必须挑选出具体使用哪个方法，对比定义的参数类型和传入的值类型是否一致来进行匹配，若找不到则会发生编译错误，这个查找过程叫做**重载解析**

所有方法都可以重载，完整地描述一个方法需要指定方法名和参数类型，这叫做**方法的签名**，返回类型不是签名的一部分

### 4.6.2 默认字段初始化

如果没有为字段显式地赋予初值，那么就会使用默认值，如null和0、false，这不是一种良好的编程习惯，容易犯错


### 4.6.3 无参数的构造器

如果写一个类时没有写构造器，那么会自动给你添加一个无参数的构造器，此构造器会将所有字段设为默认值

如果提供了至少一个构造器，但是没有提供无参数构造器，那么构造对象的时候不提供参数就是不合法的


### 4.6.4 显式字段初始化

不管怎样调用构造器，显式地为每一个实例字段提供一个初始值是好的

可以在类定义中直接赋予初值，在调用构造器前会完成这一操作，如果所有的构造器都想设置成这个值，那么就会很有用

初始值也可以不是常量

### 4.6.5 参数名

通常喜欢使用单个字母作为参数名，但这么做只有阅读代码才知道其含义

可以在在完整的参数名前加个a，这样能够帮助理解

还有一种技巧，参数名会遮蔽实例字段，但是还可以使用this访问实例字段，`this.salary = salary`，this指示隐式参数代表实例对象

### 4.6.6 调用另一个构造器

this除了作为隐式参数代表实例对象外，还可以用来调用另一个构造器

如果在构造器中的语句如`this(...)`，构造器将调用同一个类的另一个构造器

### 4.6.7 初始化块

前面已经有了两种初始化字段的方法

* 在构造器中设置
* 在类定义（声明）中赋值

还有另一种方式，叫做初始化块。即在类定义中使用代码块为字段赋值，每当构造对象的时候都会调用，无论哪个构造器。

这种机制不是必须的，也不常见。

下面是调用构造器的具体步骤：

1. 如果构造器第一行是`this(...)`，调用另一个构造器
2. 否则
    * 所有数据字段初始化为默认值，null、0、false
    * 执行类定义中声明的赋值
3. 执行构造器主体代码

最后我们应该精心组织好初始化代码，以便于其他程序员理解

如果类的静态字段需要很复杂的初始化代码，那么可以使用一个静态的初始化块，用static关键字标记

## 4.7 包

借助包可以管理和组织代码，将自己和他人的代码分开管理

### 4.7.1 包名

使用包的主要原因是确保类的唯一性，例如有两个类都叫Employee，只要将他们放在不同的包就可以区分

为了保证包名的绝对唯一，要用一个域名的逆序方式书写，并在最后加上一个工程名，比如`com.horstman.corejava`

再把Employee这个类放入这个包里，那么这个类的**完全限定名**（fully qualified name）就叫做`com.horstman.corejava.Employee`

### 4.7.2 类的导入

一个类能访问同一个包的所有类，能访问其他包中的公共类

类可以通过完全限定名直接使用，但那样太繁琐了，例如

```java
java.time.LocalDate today = java.time.LocalDate.now();
```

更简单的方法是使用import语句，导入包中的各个类，例如

```java
import java.time.*;

// 然后就可以使用
LocalDate today = LocalDate.now();
```

也可以导入一个包中具体的类：

```java
import java.time.LocalDate;
```

注意：一次只能导入一个包，类似`import java.*`和`import java.*.*`都是不允许的

如果使用通配符导入两个包中的所有类，并且有重复的类名的话，可以在这两条导入语句之后再具体指定使用哪个包中的类。


### 4.7.3 静态导入

有一种语法允许导入一个类的静态字段和方法

```java
import static java.lang.System.*;

out.println("Goodbye world"); // ie:System.out
exit(0); // ie:System.exit
```

### 4.7.4 在包中增加类

将包名放在原文件的头部，并且将源文件放在正确的文件夹下，例如

```java
package com.horstmann.corejava;

public class Employee {
    // ...
}
```

对应目录结构：

com/horstmann/corejava

要编译和运行一个包中的类，则要从基目录编译和运行，例如

javac com/horstmann/corejava/Employee.java

java com.horstmann.corejava.Employee

注意编译时带有/分隔符和.java拓展名，运行时带有.分隔符

### 4.7.5 包访问

标记为public的部分（类、变量、方法）可以由任何类使用，标记为private的部分只能由定义这部分的类使用，如果没有指定则能被同一个包中的所有方法访问

### 4.7.6 类路径

在前面已经看到类存储在文件系统的子目录中。类的路径必须与包名匹配。

类文件（.class文件）可以存储在JAR（Java归档）文件中，可以节省空间改善性能，JAR文件使用ZIP格式组织文件和目录

为了使类能够被多个程序共享，需要做到以下几点

1. 把类文件放到一个目录中，比如/home/user/classdir，增加com.horstmann.corejava.Employee类就要放到/home/user/classdir/com/horstmann/corejava目录下
2. 将JAR文件放到一个目录中，比如/home/user/archives
3. 设置类路径（class path）。类路径是包含所有类文件的路径的集合。
    * 在UNIX环境下使用冒号（:）分隔，比如/home/user/classdir:.:/home/user/archives/archive.jar
    * 在Windows环境下用分号（;）分隔，比如c:\classdir;.;c:\archives\archive.jar

注意：javac总是在当前目录下查找类文件，而Java虚拟机仅在类路径包含“.”目录时才会查看当前目录。

比如Java虚拟机查找com.horstmann.corejava.Employee类，首先它会在Java API中寻找，显然找不到转而查看类路径，然后它会在/home/user/classdir/com/horstmann/corejava目录下查找，若找不到则在当前目录下查找，最后在JAR包目录下查找

编译器查找类的过程：比如引用了Employee类，首先会查看所有的import指令，首先从java.lang包开始（这个包总是默认导入的），然后依次查找，包括当前包，然后在类路径所有位置上查找。如果找到了一个以上的类，就会产生编译时错误。

编译器查找公共类总是很容易，因为公共类的名字和源文件名字相同。但源文件还可以在当前包中导入非公共类，这时编译器就要搜索当前包中的所有源文件，查看哪个源文件定义了这个类。

### 4.7.7 设置类路径

使用`-classpath`（或`-cp`，Java 9中的选项）指定类路径，例如

`java -classpath /home/user/classdir:.:/home/user/archives/archive.jar MyProg`

## 4.8 JAR文件

...

## 4.9 文档注释

...

## 4.10 类的设计技巧

1. 保持数据私有
2. 一定要对数据初始化
3. 不要在类中过多的使用基本类型
4. 不是所有字段都需要访问器和字段更改器
5. 分解具有过多职责的类
6. 类名和方法名要能够体现他们的职责
    * 类名应当是一个名词（Order），或者一个形容词修饰的名词（RushOrder），或者动名词（BillingAddress）
    * 访问器开头字母小写，以get-开头，更改器以set-开头
7. 优先使用不可变更的类
    * 这在多线程情形下有用处

