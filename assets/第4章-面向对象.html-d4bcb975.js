import{_ as a,p as s,q as n,a1 as e}from"./framework-6f85e614.js";const p={},i=e(`<h1 id="第4章-面向对象" tabindex="-1"><a class="header-anchor" href="#第4章-面向对象" aria-hidden="true">#</a> 第4章 面向对象</h1><h2 id="_4-6-对象构造" tabindex="-1"><a class="header-anchor" href="#_4-6-对象构造" aria-hidden="true">#</a> 4.6 对象构造</h2><h3 id="_4-6-1-重载" tabindex="-1"><a class="header-anchor" href="#_4-6-1-重载" aria-hidden="true">#</a> 4.6.1 重载</h3><p>类可以有多个构造器，根据参数不同做区分，这种功能叫做<strong>重载</strong></p><p>编译器必须挑选出具体使用哪个方法，对比定义的参数类型和传入的值类型是否一致来进行匹配，若找不到则会发生编译错误，这个查找过程叫做<strong>重载解析</strong></p><p>所有方法都可以重载，完整地描述一个方法需要指定方法名和参数类型，这叫做<strong>方法的签名</strong>，返回类型不是签名的一部分</p><h3 id="_4-6-2-默认字段初始化" tabindex="-1"><a class="header-anchor" href="#_4-6-2-默认字段初始化" aria-hidden="true">#</a> 4.6.2 默认字段初始化</h3><p>如果没有为字段显式地赋予初值，那么就会使用默认值，如null和0、false，这不是一种良好的编程习惯，容易犯错</p><h3 id="_4-6-3-无参数的构造器" tabindex="-1"><a class="header-anchor" href="#_4-6-3-无参数的构造器" aria-hidden="true">#</a> 4.6.3 无参数的构造器</h3><p>如果写一个类时没有写构造器，那么会自动给你添加一个无参数的构造器，此构造器会将所有字段设为默认值</p><p>如果提供了至少一个构造器，但是没有提供无参数构造器，那么构造对象的时候不提供参数就是不合法的</p><h3 id="_4-6-4-显式字段初始化" tabindex="-1"><a class="header-anchor" href="#_4-6-4-显式字段初始化" aria-hidden="true">#</a> 4.6.4 显式字段初始化</h3><p>不管怎样调用构造器，显式地为每一个实例字段提供一个初始值是好的</p><p>可以在类定义中直接赋予初值，在调用构造器前会完成这一操作，如果所有的构造器都想设置成这个值，那么就会很有用</p><p>初始值也可以不是常量</p><h3 id="_4-6-5-参数名" tabindex="-1"><a class="header-anchor" href="#_4-6-5-参数名" aria-hidden="true">#</a> 4.6.5 参数名</h3><p>通常喜欢使用单个字母作为参数名，但这么做只有阅读代码才知道其含义</p><p>可以在在完整的参数名前加个a，这样能够帮助理解</p><p>还有一种技巧，参数名会遮蔽实例字段，但是还可以使用this访问实例字段，<code>this.salary = salary</code>，this指示隐式参数代表实例对象</p><h3 id="_4-6-6-调用另一个构造器" tabindex="-1"><a class="header-anchor" href="#_4-6-6-调用另一个构造器" aria-hidden="true">#</a> 4.6.6 调用另一个构造器</h3><p>this除了作为隐式参数代表实例对象外，还可以用来调用另一个构造器</p><p>如果在构造器中的语句如<code>this(...)</code>，构造器将调用同一个类的另一个构造器</p><h3 id="_4-6-7-初始化块" tabindex="-1"><a class="header-anchor" href="#_4-6-7-初始化块" aria-hidden="true">#</a> 4.6.7 初始化块</h3><p>前面已经有了两种初始化字段的方法</p><ul><li>在构造器中设置</li><li>在类定义（声明）中赋值</li></ul><p>还有另一种方式，叫做初始化块。即在类定义中使用代码块为字段赋值，每当构造对象的时候都会调用，无论哪个构造器。</p><p>这种机制不是必须的，也不常见。</p><p>下面是调用构造器的具体步骤：</p><ol><li>如果构造器第一行是<code>this(...)</code>，调用另一个构造器</li><li>否则 <ul><li>所有数据字段初始化为默认值，null、0、false</li><li>执行类定义中声明的赋值</li></ul></li><li>执行构造器主体代码</li></ol><p>最后我们应该精心组织好初始化代码，以便于其他程序员理解</p><p>如果类的静态字段需要很复杂的初始化代码，那么可以使用一个静态的初始化块，用static关键字标记</p><h2 id="_4-7-包" tabindex="-1"><a class="header-anchor" href="#_4-7-包" aria-hidden="true">#</a> 4.7 包</h2><p>借助包可以管理和组织代码，将自己和他人的代码分开管理</p><h3 id="_4-7-1-包名" tabindex="-1"><a class="header-anchor" href="#_4-7-1-包名" aria-hidden="true">#</a> 4.7.1 包名</h3><p>使用包的主要原因是确保类的唯一性，例如有两个类都叫Employee，只要将他们放在不同的包就可以区分</p><p>为了保证包名的绝对唯一，要用一个域名的逆序方式书写，并在最后加上一个工程名，比如<code>com.horstman.corejava</code></p><p>再把Employee这个类放入这个包里，那么这个类的<strong>完全限定名</strong>（fully qualified name）就叫做<code>com.horstman.corejava.Employee</code></p><h3 id="_4-7-2-类的导入" tabindex="-1"><a class="header-anchor" href="#_4-7-2-类的导入" aria-hidden="true">#</a> 4.7.2 类的导入</h3><p>一个类能访问同一个包的所有类，能访问其他包中的公共类</p><p>类可以通过完全限定名直接使用，但那样太繁琐了，例如</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span>LocalDate</span> today <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span>LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>更简单的方法是使用import语句，导入包中的各个类，例如</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token comment">// 然后就可以使用</span>
<span class="token class-name">LocalDate</span> today <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以导入一个包中具体的类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>time<span class="token punctuation">.</span></span><span class="token class-name">LocalDate</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意：一次只能导入一个包，类似<code>import java.*</code>和<code>import java.*.*</code>都是不允许的</p><p>如果使用通配符导入两个包中的所有类，并且有重复的类名的话，可以在这两条导入语句之后再具体指定使用哪个包中的类。</p><h3 id="_4-7-3-静态导入" tabindex="-1"><a class="header-anchor" href="#_4-7-3-静态导入" aria-hidden="true">#</a> 4.7.3 静态导入</h3><p>有一种语法允许导入一个类的静态字段和方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span>

out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Goodbye world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ie:System.out</span>
<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ie:System.exit</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-7-4-在包中增加类" tabindex="-1"><a class="header-anchor" href="#_4-7-4-在包中增加类" aria-hidden="true">#</a> 4.7.4 在包中增加类</h3><p>将包名放在原文件的头部，并且将源文件放在正确的文件夹下，例如</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>horstmann<span class="token punctuation">.</span>corejava</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应目录结构：</p><p>com/horstmann/corejava</p><p>要编译和运行一个包中的类，则要从基目录编译和运行，例如</p><p>javac com/horstmann/corejava/Employee.java</p><p>java com.horstmann.corejava.Employee</p><p>注意编译时带有/分隔符和.java拓展名，运行时带有.分隔符</p><h3 id="_4-7-5-包访问" tabindex="-1"><a class="header-anchor" href="#_4-7-5-包访问" aria-hidden="true">#</a> 4.7.5 包访问</h3><p>标记为public的部分（类、变量、方法）可以由任何类使用，标记为private的部分只能由定义这部分的类使用，如果没有指定则能被同一个包中的所有方法访问</p><h3 id="_4-7-6-类路径" tabindex="-1"><a class="header-anchor" href="#_4-7-6-类路径" aria-hidden="true">#</a> 4.7.6 类路径</h3><p>在前面已经看到类存储在文件系统的子目录中。类的路径必须与包名匹配。</p><p>类文件（.class文件）可以存储在JAR（Java归档）文件中，可以节省空间改善性能，JAR文件使用ZIP格式组织文件和目录</p><p>为了使类能够被多个程序共享，需要做到以下几点</p><ol><li>把类文件放到一个目录中，比如/home/user/classdir，增加com.horstmann.corejava.Employee类就要放到/home/user/classdir/com/horstmann/corejava目录下</li><li>将JAR文件放到一个目录中，比如/home/user/archives</li><li>设置类路径（class path）。类路径是包含所有类文件的路径的集合。 <ul><li>在UNIX环境下使用冒号（:）分隔，比如/home/user/classdir:.:/home/user/archives/archive.jar</li><li>在Windows环境下用分号（;）分隔，比如c:\\classdir;.;c:\\archives\\archive.jar</li></ul></li></ol><p>注意：javac总是在当前目录下查找类文件，而Java虚拟机仅在类路径包含“.”目录时才会查看当前目录。</p><p>比如Java虚拟机查找com.horstmann.corejava.Employee类，首先它会在Java API中寻找，显然找不到转而查看类路径，然后它会在/home/user/classdir/com/horstmann/corejava目录下查找，若找不到则在当前目录下查找，最后在JAR包目录下查找</p><p>编译器查找类的过程：比如引用了Employee类，首先会查看所有的import指令，首先从java.lang包开始（这个包总是默认导入的），然后依次查找，包括当前包，然后在类路径所有位置上查找。如果找到了一个以上的类，就会产生编译时错误。</p><p>编译器查找公共类总是很容易，因为公共类的名字和源文件名字相同。但源文件还可以在当前包中导入非公共类，这时编译器就要搜索当前包中的所有源文件，查看哪个源文件定义了这个类。</p><h3 id="_4-7-7-设置类路径" tabindex="-1"><a class="header-anchor" href="#_4-7-7-设置类路径" aria-hidden="true">#</a> 4.7.7 设置类路径</h3><p>使用<code>-classpath</code>（或<code>-cp</code>，Java 9中的选项）指定类路径，例如</p><p><code>java -classpath /home/user/classdir:.:/home/user/archives/archive.jar MyProg</code></p><h2 id="_4-8-jar文件" tabindex="-1"><a class="header-anchor" href="#_4-8-jar文件" aria-hidden="true">#</a> 4.8 JAR文件</h2><p>...</p><h2 id="_4-9-文档注释" tabindex="-1"><a class="header-anchor" href="#_4-9-文档注释" aria-hidden="true">#</a> 4.9 文档注释</h2><p>...</p><h2 id="_4-10-类的设计技巧" tabindex="-1"><a class="header-anchor" href="#_4-10-类的设计技巧" aria-hidden="true">#</a> 4.10 类的设计技巧</h2><ol><li>保持数据私有</li><li>一定要对数据初始化</li><li>不要在类中过多的使用基本类型</li><li>不是所有字段都需要访问器和字段更改器</li><li>分解具有过多职责的类</li><li>类名和方法名要能够体现他们的职责 <ul><li>类名应当是一个名词（Order），或者一个形容词修饰的名词（RushOrder），或者动名词（BillingAddress）</li><li>访问器开头字母小写，以get-开头，更改器以set-开头</li></ul></li><li>优先使用不可变更的类 <ul><li>这在多线程情形下有用处</li></ul></li></ol>`,79),c=[i];function t(o,l){return s(),n("div",null,c)}const d=a(p,[["render",t],["__file","第4章-面向对象.html.vue"]]);export{d as default};
